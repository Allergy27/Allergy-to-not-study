# 背包问题

背包问题一共分为三种,01背包，完全背包，多重背包。
其中多重背包要了解二进制优化。

## 三种背包问题

### 零一背包

- **问题介绍：** 有一个有限容量的背包，要装n种n个物品，物品占不同容量、有不同价值，求出最大能装下的价值

- **算法分析：**
  - 首先我们知道01背包问题最核心的就是取还是不取，这个问题可以联系到最经典的**捡芝麻丢西瓜**小故事。而与之不同的是我们要做出正确的决策
  - 我们来想想看，什么样的决策是**正确**的？
    - 在背包里**没有东西**的时候，我们见到一个东西就拿一个东西是对的
    - 在背包里装不下新的东西的时候，我们就需要做一些取舍，丢掉一部分的物品，转而装下新东西（当然，**新东西需要更有价值**
    - 于是我们就可以先遍历东西，再从背包是空的情况向满的情况开始遍历，如果这个东西放进来**更有价值**我们就让它放进来
  - 那么我们理解了这个决策的方法后，就可以用更学术的语言来描述这个过程了
    - 我们设出一个dp表记作**背包对应容量下能获得的最大价值**
    - 接着我们开始遍历
    - 外层遍历物品，内层遍历背包的容量，而遍历过程中的**状态转移方程**则为：$dp[j]=max(dp[j],dp[j-w[i]]+v[i])$
  - 写出这个状态转移方程之后其实就可以直接写代码了，但是初次接触这个概念可能显得比较抽象，我们用一些图片来辅助理解:
  - ![西瓜](https://gitee.com/deer-b/picture/raw/master/img/20231126155510.png)
  我自拟了一个简单的01背包问题，那么我们直接模拟一下上面那个策略的执行过程：
  - 首先我们遇到了重量为2，价值为3的西瓜，没什么好说的这遍循环直接将其加入:
  ![图1](https://gitee.com/deer-b/picture/raw/master/img/20231126155858.png)
  - 接着我们遇到了3 4的西瓜，我们开始判断了：
  ![图2](https://gitee.com/deer-b/picture/raw/master/img/20231126160235.png)
  - 因为容量是7，所以7-3 ~（这个西瓜）~=4是4的位置，我们判断容量为4的最大值也就是3加上这个新东西4是否比原先容量为7时的值大。而7很显然大于3，我们替换：
  ![图3](https://gitee.com/deer-b/picture/raw/master/img/20231126160546.png)
  - 接着依次类推直到下面这种情况:
  ![图4](https://gitee.com/deer-b/picture/raw/master/img/20231126160644.png)
  - 其实没必要单领出来，但是这时是有**一点点不一样**的，我们能发现这时左边的不是3而是0了，所以我们比较的是0+4和3的大小关系，显然4更大些，接着类推直到包已经满了:
  ![图5](https://gitee.com/deer-b/picture/raw/master/img/20231126160857.png)
  - 这时我们就接着判断下一个物品了，那么中间过程交给大火**自己写**了，我这里贴出**最终的状态**以供验证:
  ![图6](https://gitee.com/deer-b/picture/raw/master/img/20231126161156.png)
- **代码部分：**

  _老规矩昂，只有主体部分_

```C++
void solve() {
    int n, v, i, j;
    cin >> v >> n;
    vector<int>qwq(v + 1, 0);
    vector<int>qwqV(n + 1, 0);
    vector<int>qwqW(n + 1, 0);
    //输入物品及价值
    for(i = 1;i <= n;++i)cin >> qwqW[i] >> qwqV[i];
    //动态规划
    for(i = 1;i <= n;++i)
        for(j = v;j >=qwqW[i];--j)
            qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]);
    cout << qwq[v] << '\n';
}
```

- 理解完这个西瓜的题目之后，我们去**洛谷**做一下也是相当经典的[采药问题](https://www.luogu.com.cn/problem/P1048)

---

### 完全背包

- **问题介绍：** 从n种n个物品改成了n种**无限个**物品。
- **算法分析：**
  - 那么相信大火已经把01背包搞懂了，我们来搞懂**完全背包问题**
    - 其实这个问题就是01背包反过来做，我们原先是从后往前遍历的，现在我们从前往后遍历
    - 就是指每当遇到一个东西，我们都用它塞满背包，最后塞满时的状态就是最后我们要的答案
  - 理解起来应该不难，代码上也**只需要改一点，** 所以我们直接给出题目并且附赠一个题解：
  [疯狂的采药](https://www.luogu.com.cn/problem/P1616)

- **题解：**

```C++
void solve() {
    ll n, v, i, j;
    cin >> v >> n;
    vector<ll>qwq(v + 1, 0);
    vector<ll>qwqV(n + 1, 0);
    vector<ll>qwqW(n + 1, 0);
    //输入物品及价值
    for(i = 1;i <= n;++i)cin >> qwqW[i] >> qwqV[i];
    //动态规划
    for(i = 1;i <= n;++i)
        for(j = qwqW[i];j<=v;++j) //保证了一定不越界
            qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]); //要么取，要么不取，不考虑空间用完
    cout << qwq[v] << '\n';
}
```

---

### 多重背包

- **问题介绍：** 从n种n个变成了n种m个，也就是每种可能有多个
- **算法分析：**
  - 其实就是一个01背包问题，试想一下，我们将每种的多个都拆出来，是不是直接转换成了01背包问题
  - 但是我们还需要优化（试想一下，我有两个物品，其中一个是1 1 1000000，那我如果转化的话，是不是不止2个物品的讨论情况了
    - 但是也许你也注意到了，1000000个的话，我的背包可能根本装不完
    - 是的，这样我们就转换成了完全背包+01背包问题
  - 不过我们采取**别的方法**优化（主要是为了有东西可以写……）
    - 我们来考虑一下将一个**物品的数量**分解：
    - 如果是1 1 20，那我们可以拆成$(1+2+4+8)+5$
    - 为什么不是$4+16$呢？
    - 这是因为，前面括号括起来的数全是**2的n次幂**，我们可以用`<<`来实现轻松**枚举**，而4 16则没有明显的枚举关系（你可能会说4^1 4^2,总之因为位运算是二进制，符合2的n次都是可以的(不过取这些**也许会得到错误的答案**，不妨尝试一下)）
- 那么我们直接用一道[宝物筛选](https://www.luogu.com.cn/problem/P1776)来巩固一下吧

- **题解：**

```C++
void solve() {
    int n, v, i, j, num, cnt = 0, a, b;
    cin >> n >> v;
    vector<int>qwq(1000005, 0);
    vector<int>qwqV(1000005, 0);
    vector<int>qwqW(1000005, 0);
    //输入物品及价值(二进制优化)
    for(i = 1;i <= n;++i) {
        cin >> a >> b >> num;
        for(j = 1;j <= num;j <<= 1) {
            qwqV[++cnt] = j * a;
            qwqW[cnt] = j * b;
            num -= j;
        }
        if(num)qwqV[++cnt] = a * num, qwqW[cnt] = b * num;
    }
    //动态规划
    for(i = 1;i <= cnt;++i)
        for(j = v;j >= qwqW[i];--j) //保证了一定不越界
             qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]); //要么取，要么不取，不考虑空间用完
    cout << qwq[v] << '\n';
}
```
